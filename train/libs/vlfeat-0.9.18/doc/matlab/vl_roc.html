<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
   <html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <!-- IE Standards Mode -->
  <meta content="IE=edge" http-equiv="X-UA-Compatible"></meta>

  <!-- Favicon -->
  <link href="../images/vl_blue.ico" type="image/x-icon" rel="icon"></link>
  <link href="../images/vl_blue.ico" type="image/x-icon" rel="shortcut icon"></link>

  <!-- Page title -->
  <title>VLFeat - Documentation > MATLAB API > PLOTOP - vl_roc</title>

  <!-- Stylesheets -->
  <link href="../vlfeat.css" type="text/css" rel="stylesheet"></link>
  <link href="../pygmentize.css" type="text/css" rel="stylesheet"></link>
  <style xml:space="preserve">
    /* fixes a conflict between Pygmentize and MathJax */
    .MathJax .mo, .MathJax .mi {color: inherit ! important}
  </style>
  

  <!-- Scripts-->
  

  <!-- MathJax -->
  <script xml:space="preserve" type="text/x-mathjax-config">
    MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ['\\(','\\)'] ],
      processEscapes: true,
    },
    TeX: {
      Macros: {
        balpha: '\\boldsymbol{\\alpha}',
        bc: '\\mathbf{c}',
        be: '\\mathbf{e}',
        bg: '\\mathbf{g}',
        bq: '\\mathbf{q}',
        bu: '\\mathbf{u}',
        bv: '\\mathbf{v}',
        bw: '\\mathbf{w}',
        bx: '\\mathbf{x}',
        by: '\\mathbf{y}',
        bz: '\\mathbf{z}',
        bsigma: '\\mathbf{\\sigma}',
        sign: '\\operatorname{sign}',
        diag: '\\operatorname{diag}',
        real: '\\mathbb{R}',
      },
      equationNumbers: { autoNumber: 'AMS' }
      }
    });
  </script>
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" xml:space="preserve" type="text/javascript"></script>

  <!-- Google Custom Search -->
  <script xml:space="preserve">
    (function() {
    var cx = '003215582122030917471:oq23albfeam';
    var gcse = document.createElement('script'); gcse.type = 'text/javascript'; gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
    '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(gcse, s);
    })();
  </script>

  <!-- Google Analytics -->
  <script xml:space="preserve" type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-4936091-2']);
    _gaq.push(['_trackPageview']);
    (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
 </head>

 <!-- Body Start -->
 <body>
  <div id="header-section">
    <div id="header">
      <!-- Google CSE Search Box -->
      <div id="google" class="gcse-searchbox-only" data-resultsUrl="http://www.vlfeat.org/search.html"></div>
      <h1 id="id-14"><a shape="rect" href="../index.html" class="plain"><span id="vlfeat">VLFeat</span><span id="dotorg">.org</span></a></h1>
    </div>
    <div id="sidebar"> <!-- Navigation Start -->
      <ul>
<li><a href="../index.html">Home</a>
<ul>
<li><a href="../about.html">About</a>
</li>
<li><a href="../license.html">License</a>
</li>
</ul></li>
<li><a href="../download.html">Download</a>
<ul>
<li><a href="../install-matlab.html">Using from MATLAB</a>
</li>
<li><a href="../install-octave.html">Using from Octave</a>
</li>
<li><a href="../install-shell.html">Using from the command line</a>
</li>
<li><a href="../install-c.html">Using from C</a>
<ul>
<li><a href="../xcode.html">Xcode</a>
</li>
<li><a href="../vsexpress.html">Visual C++</a>
</li>
<li><a href="../gcc.html">g++</a>
</li>
</ul></li>
<li><a href="../compiling.html">Compiling</a>
<ul>
<li><a href="../compiling-unix.html">Compiling on UNIX-like platforms</a>
</li>
<li><a href="../compiling-windows.html">Compiling on Windows</a>
</li>
</ul></li>
</ul></li>
<li><a href="../overview/tut.html">Tutorials</a>
<ul>
<li><a href="../overview/frame.html">Local feature frames</a>
</li>
<li><a href="../overview/covdet.html">Covariant feature detectors</a>
</li>
<li><a href="../overview/hog.html">HOG features</a>
</li>
<li><a href="../overview/sift.html">SIFT detector and descriptor</a>
</li>
<li><a href="../overview/dsift.html">Dense SIFT</a>
</li>
<li><a href="../overview/liop.html">LIOP local descriptor</a>
</li>
<li><a href="../overview/mser.html">MSER feature detector</a>
</li>
<li><a href="../overview/imdisttf.html">Distance transform</a>
</li>
<li><a href="../overview/encodings.html">Fisher Vector and VLAD</a>
</li>
<li><a href="../overview/gmm.html">Gaussian Mixture Models</a>
</li>
<li><a href="../overview/kmeans.html">K-means clustering</a>
</li>
<li><a href="../overview/aib.html">Agglomerative Infromation Bottleneck</a>
</li>
<li><a href="../overview/quickshift.html">Quick shift superpixels</a>
</li>
<li><a href="../overview/slic.html">SLIC superpixels</a>
</li>
<li><a href="../overview/svm.html#tut.svm">Support Vector Machines (SVMs)</a>
</li>
<li><a href="../overview/kdtree.html">KD-trees and forests</a>
</li>
<li><a href="../overview/plots-rank.html">Plotting AP and ROC curves</a>
</li>
<li><a href="../overview/utils.html">Miscellaneous utilities</a>
</li>
<li><a href="../overview/ikm.html">Integer K-means</a>
</li>
<li><a href="../overview/hikm.html">Hierarchical integer k-means</a>
</li>
</ul></li>
<li><a href="../applications/apps.html">Applications</a>
</li>
<li class='active'><a href="../doc.html">Documentation</a>
<ul>
<li class='active'><a href="matlab.html">MATLAB API</a>
</li>
<li><a href="../api/index.html">C API</a>
</li>
<li><a href="../man/man.html">Man pages</a>
<ul>
<li><a href="../man/mser.html">mser</a>
</li>
<li><a href="../man/sift.html">sift</a>
</li>
<li><a href="../man/vlfeat.html">vlfeat</a>
</li>
</ul></li>
</ul></li>
</ul>

    </div> <!-- sidebar -->
  </div>
  <div id="headbanner-section">
    <div id="headbanner">
      <span class='page'><a href="../doc.html">Documentation</a></span><span class='separator'>></span><span class='page'><a href="matlab.html">MATLAB API</a></span><span class='separator'>></span><span class='page'><a href="vl_roc.html">PLOTOP - vl_roc</a></span>
    </div>
  </div>
  <div id="content-section">
    <div id="content-wrapper">
      <div id="content">
        <div class="mdoc">
<ul class="breadcrumb"><li><a href="matlab.html">Index</a></li><li><a href="vl_printsize.html">Prev</a></li><li><a href="vl_tightsubplot.html">Next</a></li></ul><div class="documentation"><p>
[TPR,TNR] = <a href="vl_roc.html">VL_ROC</a>(LABELS, SCORES) computes the Receiver Operating
Characteristic (ROC) curve. LABELS are the ground truth labels,
greather than zero for a positive sample and smaller than zero for
a negative one. SCORES are the scores of the samples obtained from
a classifier, where lager scores should correspond to positive
labels.
</p><p>
Samples are ranked by decreasing scores, starting from rank 1.
TPR(K) and TNR(K) are the true positive and true negative rates
when samples of rank smaller or equal to K-1 are predicted to be
positive. So for example TPR(3) is the true positive rate when the
two samples with largest score are predicted to be
positive. Similarly, TPR(1) is the true positive rate when no
samples are predicted to be positive, i.e. the constant 0.
</p><p>
Set the zero the lables of samples that should be ignored in the
evaluation. Set to -INF the scores of samples which are not
retrieved. If there are samples with -INF score, then the ROC curve
may have maximum TPR and TNR smaller than 1.
</p><p>
[TPR,TNR,INFO] = <a href="vl_roc.html">VL_ROC</a>(...) returns an additional structure INFO
with the following fields:
</p><dl><dt>
info.auc
<span class="defaults">Area under the ROC curve (AUC).</span></dt><dd><p>
The ROC curve has a `staircase shape' because for each sample
only TP or TN changes, but not both at the same time. Therefore
there is no approximation involved in the computation of the
area.
</p></dd><dt>
info.eer
<span class="defaults">Equal error rate (EER).</span></dt><dd><p>
The equal error rate is the value of FPR (or FNR) when the ROC
curves intersects the line connecting (0,0) to (1,1).
</p></dd></dl><p>
<a href="vl_roc.html">VL_ROC</a>(...) with no output arguments plots the ROC curve in the
current axis.
</p><p>
<a href="vl_roc.html">VL_ROC</a>() acccepts the following options:
</p><dl><dt>
Plot
<span class="defaults">[]</span></dt><dd><p>
Setting this option turns on plotting unconditionally. The
following plot variants are supported:
</p><dl><dt>
tntp
<span class="defaults">Plot TPR against TNR (standard ROC plot).</span></dt><dt>
tptn
<span class="defaults">Plot TNR against TPR (recall on the horizontal axis).</span></dt><dt>
fptp
<span class="defaults">Plot TPR against FPR.</span></dt><dt>
fpfn
<span class="defaults">Plot FNR against FPR (similar to DET curve).</span></dt></dl></dd><dt>
NumPositives
<span class="defaults">[]</span></dt><dt>
NumNegatives
<span class="defaults">[]</span></dt><dd><p>
If set to a number, pretend that LABELS contains this may
positive/negative labels. NUMPOSITIVES/NUMNEGATIVES cannot be
smaller than the actual number of positive/negative entrires in
LABELS. The additional positive/negative labels are appended to
the end of the sequence, as if they had -INF scores (not
retrieved). This is useful to evaluate large retrieval systems in
which one stores ony a handful of top results for efficiency
reasons.
</p></dd><dt>
About the ROC curve
</dt><dd><p>
Consider a classifier that predicts as positive all samples whose
score is not smaller than a threshold S. The ROC curve represents
the performance of such classifier as the threshold S is
changed. Formally, define
</p><pre>
  P = overall num. of positive samples,
  N = overall num. of negative samples,
</pre><p>
and for each threshold S
</p><pre>
  TP(S) = num. of samples that are correctly classified as positive,
  TN(S) = num. of samples that are correctly classified as negative,
  FP(S) = num. of samples that are incorrectly classified as positive,
  FN(S) = num. of samples that are incorrectly classified as negative.
</pre><p>
Consider also the rates:
</p><pre>
  TPR = TP(S) / P,      FNR = FN(S) / P,
  TNR = TN(S) / N,      FPR = FP(S) / N,
</pre><p>
and notice that by definition
</p><pre>
  P = TP(S) + FN(S) ,    N = TN(S) + FP(S),
  1 = TPR(S) + FNR(S),   1 = TNR(S) + FPR(S).
</pre><p>
The ROC curve is the parametric curve (TPR(S), TNR(S)) obtained
as the classifier threshold S is varied in the reals. The TPR is
also known as recall (see <a href="vl_pr.html">VL_PR</a>()).
</p><p>
The ROC curve is contained in the square with vertices (0,0) The
(average) ROC curve of a random classifier is a line which
connects (1,0) and (0,1).
</p><p>
The ROC curve is independent of the prior probability of the
labels (i.e. of P/(P+N) and N/(P+N)).
</p></dd></dl><p>
REFERENCES:
[1] http://en.wikipedia.org/wiki/Receiver_operating_characteristic
</p><p>
See also: <a href="vl_pr.html">VL_PR</a>(), <a href="vl_det.html">VL_DET</a>(), <a href="vl_help.html">VL_HELP</a>().
</p></div></div>
      </div>
      <div class="clear">&nbsp;</div>
    </div>
  </div> <!-- content-section -->
  <div id="footer-section">
    <div id="footer">
      &copy; 2007-13 The authors of VLFeat
    </div> <!-- footer -->
  </div> <!-- footer section -->
 </body>
 <!-- Body ends -->
</html>
 